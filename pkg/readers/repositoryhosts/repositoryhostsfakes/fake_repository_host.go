// SPDX-FileCopyrightText: 2023 SAP SE or an SAP affiliate company and Gardener contributors
//
// SPDX-License-Identifier: Apache-2.0
// Code generated by counterfeiter. DO NOT EDIT.
package repositoryhostsfakes

import (
	"context"
	"sync"
	"time"

	"github.com/gardener/docforge/pkg/osfakes/httpclient"
	"github.com/gardener/docforge/pkg/readers/repositoryhosts"
)

type FakeRepositoryHost struct {
	AcceptStub        func(string) bool
	acceptMutex       sync.RWMutex
	acceptArgsForCall []struct {
		arg1 string
	}
	acceptReturns struct {
		result1 bool
	}
	acceptReturnsOnCall map[int]struct {
		result1 bool
	}
	FileTreeFromURLStub        func(string) ([]string, error)
	fileTreeFromURLMutex       sync.RWMutex
	fileTreeFromURLArgsForCall []struct {
		arg1 string
	}
	fileTreeFromURLReturns struct {
		result1 []string
		result2 error
	}
	fileTreeFromURLReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	GetClientStub        func() httpclient.Client
	getClientMutex       sync.RWMutex
	getClientArgsForCall []struct {
	}
	getClientReturns struct {
		result1 httpclient.Client
	}
	getClientReturnsOnCall map[int]struct {
		result1 httpclient.Client
	}
	GetRateLimitStub        func(context.Context) (int, int, time.Time, error)
	getRateLimitMutex       sync.RWMutex
	getRateLimitArgsForCall []struct {
		arg1 context.Context
	}
	getRateLimitReturns struct {
		result1 int
		result2 int
		result3 time.Time
		result4 error
	}
	getRateLimitReturnsOnCall map[int]struct {
		result1 int
		result2 int
		result3 time.Time
		result4 error
	}
	GetRawFormatLinkStub        func(string) (string, error)
	getRawFormatLinkMutex       sync.RWMutex
	getRawFormatLinkArgsForCall []struct {
		arg1 string
	}
	getRawFormatLinkReturns struct {
		result1 string
		result2 error
	}
	getRawFormatLinkReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ManifestFromURLStub        func(string) (string, error)
	manifestFromURLMutex       sync.RWMutex
	manifestFromURLArgsForCall []struct {
		arg1 string
	}
	manifestFromURLReturns struct {
		result1 string
		result2 error
	}
	manifestFromURLReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct {
	}
	nameReturns struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	ReadStub        func(context.Context, string) ([]byte, error)
	readMutex       sync.RWMutex
	readArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	readReturns struct {
		result1 []byte
		result2 error
	}
	readReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	ReadGitInfoStub        func(context.Context, string) ([]byte, error)
	readGitInfoMutex       sync.RWMutex
	readGitInfoArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	readGitInfoReturns struct {
		result1 []byte
		result2 error
	}
	readGitInfoReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	ToAbsLinkStub        func(string, string) (string, error)
	toAbsLinkMutex       sync.RWMutex
	toAbsLinkArgsForCall []struct {
		arg1 string
		arg2 string
	}
	toAbsLinkReturns struct {
		result1 string
		result2 error
	}
	toAbsLinkReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRepositoryHost) Accept(arg1 string) bool {
	fake.acceptMutex.Lock()
	ret, specificReturn := fake.acceptReturnsOnCall[len(fake.acceptArgsForCall)]
	fake.acceptArgsForCall = append(fake.acceptArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.AcceptStub
	fakeReturns := fake.acceptReturns
	fake.recordInvocation("Accept", []interface{}{arg1})
	fake.acceptMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRepositoryHost) AcceptCallCount() int {
	fake.acceptMutex.RLock()
	defer fake.acceptMutex.RUnlock()
	return len(fake.acceptArgsForCall)
}

func (fake *FakeRepositoryHost) AcceptCalls(stub func(string) bool) {
	fake.acceptMutex.Lock()
	defer fake.acceptMutex.Unlock()
	fake.AcceptStub = stub
}

func (fake *FakeRepositoryHost) AcceptArgsForCall(i int) string {
	fake.acceptMutex.RLock()
	defer fake.acceptMutex.RUnlock()
	argsForCall := fake.acceptArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepositoryHost) AcceptReturns(result1 bool) {
	fake.acceptMutex.Lock()
	defer fake.acceptMutex.Unlock()
	fake.AcceptStub = nil
	fake.acceptReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeRepositoryHost) AcceptReturnsOnCall(i int, result1 bool) {
	fake.acceptMutex.Lock()
	defer fake.acceptMutex.Unlock()
	fake.AcceptStub = nil
	if fake.acceptReturnsOnCall == nil {
		fake.acceptReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.acceptReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeRepositoryHost) FileTreeFromURL(arg1 string) ([]string, error) {
	fake.fileTreeFromURLMutex.Lock()
	ret, specificReturn := fake.fileTreeFromURLReturnsOnCall[len(fake.fileTreeFromURLArgsForCall)]
	fake.fileTreeFromURLArgsForCall = append(fake.fileTreeFromURLArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FileTreeFromURLStub
	fakeReturns := fake.fileTreeFromURLReturns
	fake.recordInvocation("FileTreeFromURL", []interface{}{arg1})
	fake.fileTreeFromURLMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepositoryHost) FileTreeFromURLCallCount() int {
	fake.fileTreeFromURLMutex.RLock()
	defer fake.fileTreeFromURLMutex.RUnlock()
	return len(fake.fileTreeFromURLArgsForCall)
}

func (fake *FakeRepositoryHost) FileTreeFromURLCalls(stub func(string) ([]string, error)) {
	fake.fileTreeFromURLMutex.Lock()
	defer fake.fileTreeFromURLMutex.Unlock()
	fake.FileTreeFromURLStub = stub
}

func (fake *FakeRepositoryHost) FileTreeFromURLArgsForCall(i int) string {
	fake.fileTreeFromURLMutex.RLock()
	defer fake.fileTreeFromURLMutex.RUnlock()
	argsForCall := fake.fileTreeFromURLArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepositoryHost) FileTreeFromURLReturns(result1 []string, result2 error) {
	fake.fileTreeFromURLMutex.Lock()
	defer fake.fileTreeFromURLMutex.Unlock()
	fake.FileTreeFromURLStub = nil
	fake.fileTreeFromURLReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryHost) FileTreeFromURLReturnsOnCall(i int, result1 []string, result2 error) {
	fake.fileTreeFromURLMutex.Lock()
	defer fake.fileTreeFromURLMutex.Unlock()
	fake.FileTreeFromURLStub = nil
	if fake.fileTreeFromURLReturnsOnCall == nil {
		fake.fileTreeFromURLReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.fileTreeFromURLReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryHost) GetClient() httpclient.Client {
	fake.getClientMutex.Lock()
	ret, specificReturn := fake.getClientReturnsOnCall[len(fake.getClientArgsForCall)]
	fake.getClientArgsForCall = append(fake.getClientArgsForCall, struct {
	}{})
	stub := fake.GetClientStub
	fakeReturns := fake.getClientReturns
	fake.recordInvocation("GetClient", []interface{}{})
	fake.getClientMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRepositoryHost) GetClientCallCount() int {
	fake.getClientMutex.RLock()
	defer fake.getClientMutex.RUnlock()
	return len(fake.getClientArgsForCall)
}

func (fake *FakeRepositoryHost) GetClientCalls(stub func() httpclient.Client) {
	fake.getClientMutex.Lock()
	defer fake.getClientMutex.Unlock()
	fake.GetClientStub = stub
}

func (fake *FakeRepositoryHost) GetClientReturns(result1 httpclient.Client) {
	fake.getClientMutex.Lock()
	defer fake.getClientMutex.Unlock()
	fake.GetClientStub = nil
	fake.getClientReturns = struct {
		result1 httpclient.Client
	}{result1}
}

func (fake *FakeRepositoryHost) GetClientReturnsOnCall(i int, result1 httpclient.Client) {
	fake.getClientMutex.Lock()
	defer fake.getClientMutex.Unlock()
	fake.GetClientStub = nil
	if fake.getClientReturnsOnCall == nil {
		fake.getClientReturnsOnCall = make(map[int]struct {
			result1 httpclient.Client
		})
	}
	fake.getClientReturnsOnCall[i] = struct {
		result1 httpclient.Client
	}{result1}
}

func (fake *FakeRepositoryHost) GetRateLimit(arg1 context.Context) (int, int, time.Time, error) {
	fake.getRateLimitMutex.Lock()
	ret, specificReturn := fake.getRateLimitReturnsOnCall[len(fake.getRateLimitArgsForCall)]
	fake.getRateLimitArgsForCall = append(fake.getRateLimitArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.GetRateLimitStub
	fakeReturns := fake.getRateLimitReturns
	fake.recordInvocation("GetRateLimit", []interface{}{arg1})
	fake.getRateLimitMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *FakeRepositoryHost) GetRateLimitCallCount() int {
	fake.getRateLimitMutex.RLock()
	defer fake.getRateLimitMutex.RUnlock()
	return len(fake.getRateLimitArgsForCall)
}

func (fake *FakeRepositoryHost) GetRateLimitCalls(stub func(context.Context) (int, int, time.Time, error)) {
	fake.getRateLimitMutex.Lock()
	defer fake.getRateLimitMutex.Unlock()
	fake.GetRateLimitStub = stub
}

func (fake *FakeRepositoryHost) GetRateLimitArgsForCall(i int) context.Context {
	fake.getRateLimitMutex.RLock()
	defer fake.getRateLimitMutex.RUnlock()
	argsForCall := fake.getRateLimitArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepositoryHost) GetRateLimitReturns(result1 int, result2 int, result3 time.Time, result4 error) {
	fake.getRateLimitMutex.Lock()
	defer fake.getRateLimitMutex.Unlock()
	fake.GetRateLimitStub = nil
	fake.getRateLimitReturns = struct {
		result1 int
		result2 int
		result3 time.Time
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeRepositoryHost) GetRateLimitReturnsOnCall(i int, result1 int, result2 int, result3 time.Time, result4 error) {
	fake.getRateLimitMutex.Lock()
	defer fake.getRateLimitMutex.Unlock()
	fake.GetRateLimitStub = nil
	if fake.getRateLimitReturnsOnCall == nil {
		fake.getRateLimitReturnsOnCall = make(map[int]struct {
			result1 int
			result2 int
			result3 time.Time
			result4 error
		})
	}
	fake.getRateLimitReturnsOnCall[i] = struct {
		result1 int
		result2 int
		result3 time.Time
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeRepositoryHost) GetRawFormatLink(arg1 string) (string, error) {
	fake.getRawFormatLinkMutex.Lock()
	ret, specificReturn := fake.getRawFormatLinkReturnsOnCall[len(fake.getRawFormatLinkArgsForCall)]
	fake.getRawFormatLinkArgsForCall = append(fake.getRawFormatLinkArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetRawFormatLinkStub
	fakeReturns := fake.getRawFormatLinkReturns
	fake.recordInvocation("GetRawFormatLink", []interface{}{arg1})
	fake.getRawFormatLinkMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepositoryHost) GetRawFormatLinkCallCount() int {
	fake.getRawFormatLinkMutex.RLock()
	defer fake.getRawFormatLinkMutex.RUnlock()
	return len(fake.getRawFormatLinkArgsForCall)
}

func (fake *FakeRepositoryHost) GetRawFormatLinkCalls(stub func(string) (string, error)) {
	fake.getRawFormatLinkMutex.Lock()
	defer fake.getRawFormatLinkMutex.Unlock()
	fake.GetRawFormatLinkStub = stub
}

func (fake *FakeRepositoryHost) GetRawFormatLinkArgsForCall(i int) string {
	fake.getRawFormatLinkMutex.RLock()
	defer fake.getRawFormatLinkMutex.RUnlock()
	argsForCall := fake.getRawFormatLinkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepositoryHost) GetRawFormatLinkReturns(result1 string, result2 error) {
	fake.getRawFormatLinkMutex.Lock()
	defer fake.getRawFormatLinkMutex.Unlock()
	fake.GetRawFormatLinkStub = nil
	fake.getRawFormatLinkReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryHost) GetRawFormatLinkReturnsOnCall(i int, result1 string, result2 error) {
	fake.getRawFormatLinkMutex.Lock()
	defer fake.getRawFormatLinkMutex.Unlock()
	fake.GetRawFormatLinkStub = nil
	if fake.getRawFormatLinkReturnsOnCall == nil {
		fake.getRawFormatLinkReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getRawFormatLinkReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryHost) ManifestFromURL(arg1 string) (string, error) {
	fake.manifestFromURLMutex.Lock()
	ret, specificReturn := fake.manifestFromURLReturnsOnCall[len(fake.manifestFromURLArgsForCall)]
	fake.manifestFromURLArgsForCall = append(fake.manifestFromURLArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ManifestFromURLStub
	fakeReturns := fake.manifestFromURLReturns
	fake.recordInvocation("ManifestFromURL", []interface{}{arg1})
	fake.manifestFromURLMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepositoryHost) ManifestFromURLCallCount() int {
	fake.manifestFromURLMutex.RLock()
	defer fake.manifestFromURLMutex.RUnlock()
	return len(fake.manifestFromURLArgsForCall)
}

func (fake *FakeRepositoryHost) ManifestFromURLCalls(stub func(string) (string, error)) {
	fake.manifestFromURLMutex.Lock()
	defer fake.manifestFromURLMutex.Unlock()
	fake.ManifestFromURLStub = stub
}

func (fake *FakeRepositoryHost) ManifestFromURLArgsForCall(i int) string {
	fake.manifestFromURLMutex.RLock()
	defer fake.manifestFromURLMutex.RUnlock()
	argsForCall := fake.manifestFromURLArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepositoryHost) ManifestFromURLReturns(result1 string, result2 error) {
	fake.manifestFromURLMutex.Lock()
	defer fake.manifestFromURLMutex.Unlock()
	fake.ManifestFromURLStub = nil
	fake.manifestFromURLReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryHost) ManifestFromURLReturnsOnCall(i int, result1 string, result2 error) {
	fake.manifestFromURLMutex.Lock()
	defer fake.manifestFromURLMutex.Unlock()
	fake.ManifestFromURLStub = nil
	if fake.manifestFromURLReturnsOnCall == nil {
		fake.manifestFromURLReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.manifestFromURLReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryHost) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct {
	}{})
	stub := fake.NameStub
	fakeReturns := fake.nameReturns
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRepositoryHost) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeRepositoryHost) NameCalls(stub func() string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = stub
}

func (fake *FakeRepositoryHost) NameReturns(result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeRepositoryHost) NameReturnsOnCall(i int, result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeRepositoryHost) Read(arg1 context.Context, arg2 string) ([]byte, error) {
	fake.readMutex.Lock()
	ret, specificReturn := fake.readReturnsOnCall[len(fake.readArgsForCall)]
	fake.readArgsForCall = append(fake.readArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ReadStub
	fakeReturns := fake.readReturns
	fake.recordInvocation("Read", []interface{}{arg1, arg2})
	fake.readMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepositoryHost) ReadCallCount() int {
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	return len(fake.readArgsForCall)
}

func (fake *FakeRepositoryHost) ReadCalls(stub func(context.Context, string) ([]byte, error)) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = stub
}

func (fake *FakeRepositoryHost) ReadArgsForCall(i int) (context.Context, string) {
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	argsForCall := fake.readArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepositoryHost) ReadReturns(result1 []byte, result2 error) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = nil
	fake.readReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryHost) ReadReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = nil
	if fake.readReturnsOnCall == nil {
		fake.readReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.readReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryHost) ReadGitInfo(arg1 context.Context, arg2 string) ([]byte, error) {
	fake.readGitInfoMutex.Lock()
	ret, specificReturn := fake.readGitInfoReturnsOnCall[len(fake.readGitInfoArgsForCall)]
	fake.readGitInfoArgsForCall = append(fake.readGitInfoArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ReadGitInfoStub
	fakeReturns := fake.readGitInfoReturns
	fake.recordInvocation("ReadGitInfo", []interface{}{arg1, arg2})
	fake.readGitInfoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepositoryHost) ReadGitInfoCallCount() int {
	fake.readGitInfoMutex.RLock()
	defer fake.readGitInfoMutex.RUnlock()
	return len(fake.readGitInfoArgsForCall)
}

func (fake *FakeRepositoryHost) ReadGitInfoCalls(stub func(context.Context, string) ([]byte, error)) {
	fake.readGitInfoMutex.Lock()
	defer fake.readGitInfoMutex.Unlock()
	fake.ReadGitInfoStub = stub
}

func (fake *FakeRepositoryHost) ReadGitInfoArgsForCall(i int) (context.Context, string) {
	fake.readGitInfoMutex.RLock()
	defer fake.readGitInfoMutex.RUnlock()
	argsForCall := fake.readGitInfoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepositoryHost) ReadGitInfoReturns(result1 []byte, result2 error) {
	fake.readGitInfoMutex.Lock()
	defer fake.readGitInfoMutex.Unlock()
	fake.ReadGitInfoStub = nil
	fake.readGitInfoReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryHost) ReadGitInfoReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.readGitInfoMutex.Lock()
	defer fake.readGitInfoMutex.Unlock()
	fake.ReadGitInfoStub = nil
	if fake.readGitInfoReturnsOnCall == nil {
		fake.readGitInfoReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.readGitInfoReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryHost) ToAbsLink(arg1 string, arg2 string) (string, error) {
	fake.toAbsLinkMutex.Lock()
	ret, specificReturn := fake.toAbsLinkReturnsOnCall[len(fake.toAbsLinkArgsForCall)]
	fake.toAbsLinkArgsForCall = append(fake.toAbsLinkArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.ToAbsLinkStub
	fakeReturns := fake.toAbsLinkReturns
	fake.recordInvocation("ToAbsLink", []interface{}{arg1, arg2})
	fake.toAbsLinkMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepositoryHost) ToAbsLinkCallCount() int {
	fake.toAbsLinkMutex.RLock()
	defer fake.toAbsLinkMutex.RUnlock()
	return len(fake.toAbsLinkArgsForCall)
}

func (fake *FakeRepositoryHost) ToAbsLinkCalls(stub func(string, string) (string, error)) {
	fake.toAbsLinkMutex.Lock()
	defer fake.toAbsLinkMutex.Unlock()
	fake.ToAbsLinkStub = stub
}

func (fake *FakeRepositoryHost) ToAbsLinkArgsForCall(i int) (string, string) {
	fake.toAbsLinkMutex.RLock()
	defer fake.toAbsLinkMutex.RUnlock()
	argsForCall := fake.toAbsLinkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepositoryHost) ToAbsLinkReturns(result1 string, result2 error) {
	fake.toAbsLinkMutex.Lock()
	defer fake.toAbsLinkMutex.Unlock()
	fake.ToAbsLinkStub = nil
	fake.toAbsLinkReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryHost) ToAbsLinkReturnsOnCall(i int, result1 string, result2 error) {
	fake.toAbsLinkMutex.Lock()
	defer fake.toAbsLinkMutex.Unlock()
	fake.ToAbsLinkStub = nil
	if fake.toAbsLinkReturnsOnCall == nil {
		fake.toAbsLinkReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.toAbsLinkReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryHost) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.acceptMutex.RLock()
	defer fake.acceptMutex.RUnlock()
	fake.fileTreeFromURLMutex.RLock()
	defer fake.fileTreeFromURLMutex.RUnlock()
	fake.getClientMutex.RLock()
	defer fake.getClientMutex.RUnlock()
	fake.getRateLimitMutex.RLock()
	defer fake.getRateLimitMutex.RUnlock()
	fake.getRawFormatLinkMutex.RLock()
	defer fake.getRawFormatLinkMutex.RUnlock()
	fake.manifestFromURLMutex.RLock()
	defer fake.manifestFromURLMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	fake.readGitInfoMutex.RLock()
	defer fake.readGitInfoMutex.RUnlock()
	fake.toAbsLinkMutex.RLock()
	defer fake.toAbsLinkMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeRepositoryHost) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ repositoryhosts.RepositoryHost = new(FakeRepositoryHost)
