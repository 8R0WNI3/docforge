// SPDX-FileCopyrightText: 2023 SAP SE or an SAP affiliate company and Gardener contributors
//
// SPDX-License-Identifier: Apache-2.0
// Code generated by counterfeiter. DO NOT EDIT.
package repositoryhostfakes

import (
	"context"
	"sync"
	"time"

	"github.com/gardener/docforge/pkg/osfakes/httpclient"
	"github.com/gardener/docforge/pkg/registry/repositoryhost"
)

type FakeInterface struct {
	AcceptStub        func(string) bool
	acceptMutex       sync.RWMutex
	acceptArgsForCall []struct {
		arg1 string
	}
	acceptReturns struct {
		result1 bool
	}
	acceptReturnsOnCall map[int]struct {
		result1 bool
	}
	GetClientStub        func() httpclient.Client
	getClientMutex       sync.RWMutex
	getClientArgsForCall []struct {
	}
	getClientReturns struct {
		result1 httpclient.Client
	}
	getClientReturnsOnCall map[int]struct {
		result1 httpclient.Client
	}
	GetRateLimitStub        func(context.Context) (int, int, time.Time, error)
	getRateLimitMutex       sync.RWMutex
	getRateLimitArgsForCall []struct {
		arg1 context.Context
	}
	getRateLimitReturns struct {
		result1 int
		result2 int
		result3 time.Time
		result4 error
	}
	getRateLimitReturnsOnCall map[int]struct {
		result1 int
		result2 int
		result3 time.Time
		result4 error
	}
	LoadRepositoryStub        func(context.Context, string) error
	loadRepositoryMutex       sync.RWMutex
	loadRepositoryArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	loadRepositoryReturns struct {
		result1 error
	}
	loadRepositoryReturnsOnCall map[int]struct {
		result1 error
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct {
	}
	nameReturns struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	ReadStub        func(context.Context, repositoryhost.URL) ([]byte, error)
	readMutex       sync.RWMutex
	readArgsForCall []struct {
		arg1 context.Context
		arg2 repositoryhost.URL
	}
	readReturns struct {
		result1 []byte
		result2 error
	}
	readReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	RepositoriesStub        func() repositoryhost.Repositories
	repositoriesMutex       sync.RWMutex
	repositoriesArgsForCall []struct {
	}
	repositoriesReturns struct {
		result1 repositoryhost.Repositories
	}
	repositoriesReturnsOnCall map[int]struct {
		result1 repositoryhost.Repositories
	}
	ResolveRelativeLinkStub        func(repositoryhost.URL, string) (string, error)
	resolveRelativeLinkMutex       sync.RWMutex
	resolveRelativeLinkArgsForCall []struct {
		arg1 repositoryhost.URL
		arg2 string
	}
	resolveRelativeLinkReturns struct {
		result1 string
		result2 error
	}
	resolveRelativeLinkReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ResourceURLStub        func(string) (*repositoryhost.URL, error)
	resourceURLMutex       sync.RWMutex
	resourceURLArgsForCall []struct {
		arg1 string
	}
	resourceURLReturns struct {
		result1 *repositoryhost.URL
		result2 error
	}
	resourceURLReturnsOnCall map[int]struct {
		result1 *repositoryhost.URL
		result2 error
	}
	TreeStub        func(repositoryhost.URL) ([]string, error)
	treeMutex       sync.RWMutex
	treeArgsForCall []struct {
		arg1 repositoryhost.URL
	}
	treeReturns struct {
		result1 []string
		result2 error
	}
	treeReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeInterface) Accept(arg1 string) bool {
	fake.acceptMutex.Lock()
	ret, specificReturn := fake.acceptReturnsOnCall[len(fake.acceptArgsForCall)]
	fake.acceptArgsForCall = append(fake.acceptArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.AcceptStub
	fakeReturns := fake.acceptReturns
	fake.recordInvocation("Accept", []interface{}{arg1})
	fake.acceptMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) AcceptCallCount() int {
	fake.acceptMutex.RLock()
	defer fake.acceptMutex.RUnlock()
	return len(fake.acceptArgsForCall)
}

func (fake *FakeInterface) AcceptCalls(stub func(string) bool) {
	fake.acceptMutex.Lock()
	defer fake.acceptMutex.Unlock()
	fake.AcceptStub = stub
}

func (fake *FakeInterface) AcceptArgsForCall(i int) string {
	fake.acceptMutex.RLock()
	defer fake.acceptMutex.RUnlock()
	argsForCall := fake.acceptArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeInterface) AcceptReturns(result1 bool) {
	fake.acceptMutex.Lock()
	defer fake.acceptMutex.Unlock()
	fake.AcceptStub = nil
	fake.acceptReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeInterface) AcceptReturnsOnCall(i int, result1 bool) {
	fake.acceptMutex.Lock()
	defer fake.acceptMutex.Unlock()
	fake.AcceptStub = nil
	if fake.acceptReturnsOnCall == nil {
		fake.acceptReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.acceptReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeInterface) GetClient() httpclient.Client {
	fake.getClientMutex.Lock()
	ret, specificReturn := fake.getClientReturnsOnCall[len(fake.getClientArgsForCall)]
	fake.getClientArgsForCall = append(fake.getClientArgsForCall, struct {
	}{})
	stub := fake.GetClientStub
	fakeReturns := fake.getClientReturns
	fake.recordInvocation("GetClient", []interface{}{})
	fake.getClientMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) GetClientCallCount() int {
	fake.getClientMutex.RLock()
	defer fake.getClientMutex.RUnlock()
	return len(fake.getClientArgsForCall)
}

func (fake *FakeInterface) GetClientCalls(stub func() httpclient.Client) {
	fake.getClientMutex.Lock()
	defer fake.getClientMutex.Unlock()
	fake.GetClientStub = stub
}

func (fake *FakeInterface) GetClientReturns(result1 httpclient.Client) {
	fake.getClientMutex.Lock()
	defer fake.getClientMutex.Unlock()
	fake.GetClientStub = nil
	fake.getClientReturns = struct {
		result1 httpclient.Client
	}{result1}
}

func (fake *FakeInterface) GetClientReturnsOnCall(i int, result1 httpclient.Client) {
	fake.getClientMutex.Lock()
	defer fake.getClientMutex.Unlock()
	fake.GetClientStub = nil
	if fake.getClientReturnsOnCall == nil {
		fake.getClientReturnsOnCall = make(map[int]struct {
			result1 httpclient.Client
		})
	}
	fake.getClientReturnsOnCall[i] = struct {
		result1 httpclient.Client
	}{result1}
}

func (fake *FakeInterface) GetRateLimit(arg1 context.Context) (int, int, time.Time, error) {
	fake.getRateLimitMutex.Lock()
	ret, specificReturn := fake.getRateLimitReturnsOnCall[len(fake.getRateLimitArgsForCall)]
	fake.getRateLimitArgsForCall = append(fake.getRateLimitArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.GetRateLimitStub
	fakeReturns := fake.getRateLimitReturns
	fake.recordInvocation("GetRateLimit", []interface{}{arg1})
	fake.getRateLimitMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *FakeInterface) GetRateLimitCallCount() int {
	fake.getRateLimitMutex.RLock()
	defer fake.getRateLimitMutex.RUnlock()
	return len(fake.getRateLimitArgsForCall)
}

func (fake *FakeInterface) GetRateLimitCalls(stub func(context.Context) (int, int, time.Time, error)) {
	fake.getRateLimitMutex.Lock()
	defer fake.getRateLimitMutex.Unlock()
	fake.GetRateLimitStub = stub
}

func (fake *FakeInterface) GetRateLimitArgsForCall(i int) context.Context {
	fake.getRateLimitMutex.RLock()
	defer fake.getRateLimitMutex.RUnlock()
	argsForCall := fake.getRateLimitArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeInterface) GetRateLimitReturns(result1 int, result2 int, result3 time.Time, result4 error) {
	fake.getRateLimitMutex.Lock()
	defer fake.getRateLimitMutex.Unlock()
	fake.GetRateLimitStub = nil
	fake.getRateLimitReturns = struct {
		result1 int
		result2 int
		result3 time.Time
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeInterface) GetRateLimitReturnsOnCall(i int, result1 int, result2 int, result3 time.Time, result4 error) {
	fake.getRateLimitMutex.Lock()
	defer fake.getRateLimitMutex.Unlock()
	fake.GetRateLimitStub = nil
	if fake.getRateLimitReturnsOnCall == nil {
		fake.getRateLimitReturnsOnCall = make(map[int]struct {
			result1 int
			result2 int
			result3 time.Time
			result4 error
		})
	}
	fake.getRateLimitReturnsOnCall[i] = struct {
		result1 int
		result2 int
		result3 time.Time
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeInterface) LoadRepository(arg1 context.Context, arg2 string) error {
	fake.loadRepositoryMutex.Lock()
	ret, specificReturn := fake.loadRepositoryReturnsOnCall[len(fake.loadRepositoryArgsForCall)]
	fake.loadRepositoryArgsForCall = append(fake.loadRepositoryArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.LoadRepositoryStub
	fakeReturns := fake.loadRepositoryReturns
	fake.recordInvocation("LoadRepository", []interface{}{arg1, arg2})
	fake.loadRepositoryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) LoadRepositoryCallCount() int {
	fake.loadRepositoryMutex.RLock()
	defer fake.loadRepositoryMutex.RUnlock()
	return len(fake.loadRepositoryArgsForCall)
}

func (fake *FakeInterface) LoadRepositoryCalls(stub func(context.Context, string) error) {
	fake.loadRepositoryMutex.Lock()
	defer fake.loadRepositoryMutex.Unlock()
	fake.LoadRepositoryStub = stub
}

func (fake *FakeInterface) LoadRepositoryArgsForCall(i int) (context.Context, string) {
	fake.loadRepositoryMutex.RLock()
	defer fake.loadRepositoryMutex.RUnlock()
	argsForCall := fake.loadRepositoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInterface) LoadRepositoryReturns(result1 error) {
	fake.loadRepositoryMutex.Lock()
	defer fake.loadRepositoryMutex.Unlock()
	fake.LoadRepositoryStub = nil
	fake.loadRepositoryReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInterface) LoadRepositoryReturnsOnCall(i int, result1 error) {
	fake.loadRepositoryMutex.Lock()
	defer fake.loadRepositoryMutex.Unlock()
	fake.LoadRepositoryStub = nil
	if fake.loadRepositoryReturnsOnCall == nil {
		fake.loadRepositoryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.loadRepositoryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInterface) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct {
	}{})
	stub := fake.NameStub
	fakeReturns := fake.nameReturns
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeInterface) NameCalls(stub func() string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = stub
}

func (fake *FakeInterface) NameReturns(result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeInterface) NameReturnsOnCall(i int, result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeInterface) Read(arg1 context.Context, arg2 repositoryhost.URL) ([]byte, error) {
	fake.readMutex.Lock()
	ret, specificReturn := fake.readReturnsOnCall[len(fake.readArgsForCall)]
	fake.readArgsForCall = append(fake.readArgsForCall, struct {
		arg1 context.Context
		arg2 repositoryhost.URL
	}{arg1, arg2})
	stub := fake.ReadStub
	fakeReturns := fake.readReturns
	fake.recordInvocation("Read", []interface{}{arg1, arg2})
	fake.readMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInterface) ReadCallCount() int {
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	return len(fake.readArgsForCall)
}

func (fake *FakeInterface) ReadCalls(stub func(context.Context, repositoryhost.URL) ([]byte, error)) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = stub
}

func (fake *FakeInterface) ReadArgsForCall(i int) (context.Context, repositoryhost.URL) {
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	argsForCall := fake.readArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInterface) ReadReturns(result1 []byte, result2 error) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = nil
	fake.readReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeInterface) ReadReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = nil
	if fake.readReturnsOnCall == nil {
		fake.readReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.readReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeInterface) Repositories() repositoryhost.Repositories {
	fake.repositoriesMutex.Lock()
	ret, specificReturn := fake.repositoriesReturnsOnCall[len(fake.repositoriesArgsForCall)]
	fake.repositoriesArgsForCall = append(fake.repositoriesArgsForCall, struct {
	}{})
	stub := fake.RepositoriesStub
	fakeReturns := fake.repositoriesReturns
	fake.recordInvocation("Repositories", []interface{}{})
	fake.repositoriesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) RepositoriesCallCount() int {
	fake.repositoriesMutex.RLock()
	defer fake.repositoriesMutex.RUnlock()
	return len(fake.repositoriesArgsForCall)
}

func (fake *FakeInterface) RepositoriesCalls(stub func() repositoryhost.Repositories) {
	fake.repositoriesMutex.Lock()
	defer fake.repositoriesMutex.Unlock()
	fake.RepositoriesStub = stub
}

func (fake *FakeInterface) RepositoriesReturns(result1 repositoryhost.Repositories) {
	fake.repositoriesMutex.Lock()
	defer fake.repositoriesMutex.Unlock()
	fake.RepositoriesStub = nil
	fake.repositoriesReturns = struct {
		result1 repositoryhost.Repositories
	}{result1}
}

func (fake *FakeInterface) RepositoriesReturnsOnCall(i int, result1 repositoryhost.Repositories) {
	fake.repositoriesMutex.Lock()
	defer fake.repositoriesMutex.Unlock()
	fake.RepositoriesStub = nil
	if fake.repositoriesReturnsOnCall == nil {
		fake.repositoriesReturnsOnCall = make(map[int]struct {
			result1 repositoryhost.Repositories
		})
	}
	fake.repositoriesReturnsOnCall[i] = struct {
		result1 repositoryhost.Repositories
	}{result1}
}

func (fake *FakeInterface) ResolveRelativeLink(arg1 repositoryhost.URL, arg2 string) (string, error) {
	fake.resolveRelativeLinkMutex.Lock()
	ret, specificReturn := fake.resolveRelativeLinkReturnsOnCall[len(fake.resolveRelativeLinkArgsForCall)]
	fake.resolveRelativeLinkArgsForCall = append(fake.resolveRelativeLinkArgsForCall, struct {
		arg1 repositoryhost.URL
		arg2 string
	}{arg1, arg2})
	stub := fake.ResolveRelativeLinkStub
	fakeReturns := fake.resolveRelativeLinkReturns
	fake.recordInvocation("ResolveRelativeLink", []interface{}{arg1, arg2})
	fake.resolveRelativeLinkMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInterface) ResolveRelativeLinkCallCount() int {
	fake.resolveRelativeLinkMutex.RLock()
	defer fake.resolveRelativeLinkMutex.RUnlock()
	return len(fake.resolveRelativeLinkArgsForCall)
}

func (fake *FakeInterface) ResolveRelativeLinkCalls(stub func(repositoryhost.URL, string) (string, error)) {
	fake.resolveRelativeLinkMutex.Lock()
	defer fake.resolveRelativeLinkMutex.Unlock()
	fake.ResolveRelativeLinkStub = stub
}

func (fake *FakeInterface) ResolveRelativeLinkArgsForCall(i int) (repositoryhost.URL, string) {
	fake.resolveRelativeLinkMutex.RLock()
	defer fake.resolveRelativeLinkMutex.RUnlock()
	argsForCall := fake.resolveRelativeLinkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInterface) ResolveRelativeLinkReturns(result1 string, result2 error) {
	fake.resolveRelativeLinkMutex.Lock()
	defer fake.resolveRelativeLinkMutex.Unlock()
	fake.ResolveRelativeLinkStub = nil
	fake.resolveRelativeLinkReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeInterface) ResolveRelativeLinkReturnsOnCall(i int, result1 string, result2 error) {
	fake.resolveRelativeLinkMutex.Lock()
	defer fake.resolveRelativeLinkMutex.Unlock()
	fake.ResolveRelativeLinkStub = nil
	if fake.resolveRelativeLinkReturnsOnCall == nil {
		fake.resolveRelativeLinkReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.resolveRelativeLinkReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeInterface) ResourceURL(arg1 string) (*repositoryhost.URL, error) {
	fake.resourceURLMutex.Lock()
	ret, specificReturn := fake.resourceURLReturnsOnCall[len(fake.resourceURLArgsForCall)]
	fake.resourceURLArgsForCall = append(fake.resourceURLArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ResourceURLStub
	fakeReturns := fake.resourceURLReturns
	fake.recordInvocation("ResourceURL", []interface{}{arg1})
	fake.resourceURLMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInterface) ResourceURLCallCount() int {
	fake.resourceURLMutex.RLock()
	defer fake.resourceURLMutex.RUnlock()
	return len(fake.resourceURLArgsForCall)
}

func (fake *FakeInterface) ResourceURLCalls(stub func(string) (*repositoryhost.URL, error)) {
	fake.resourceURLMutex.Lock()
	defer fake.resourceURLMutex.Unlock()
	fake.ResourceURLStub = stub
}

func (fake *FakeInterface) ResourceURLArgsForCall(i int) string {
	fake.resourceURLMutex.RLock()
	defer fake.resourceURLMutex.RUnlock()
	argsForCall := fake.resourceURLArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeInterface) ResourceURLReturns(result1 *repositoryhost.URL, result2 error) {
	fake.resourceURLMutex.Lock()
	defer fake.resourceURLMutex.Unlock()
	fake.ResourceURLStub = nil
	fake.resourceURLReturns = struct {
		result1 *repositoryhost.URL
		result2 error
	}{result1, result2}
}

func (fake *FakeInterface) ResourceURLReturnsOnCall(i int, result1 *repositoryhost.URL, result2 error) {
	fake.resourceURLMutex.Lock()
	defer fake.resourceURLMutex.Unlock()
	fake.ResourceURLStub = nil
	if fake.resourceURLReturnsOnCall == nil {
		fake.resourceURLReturnsOnCall = make(map[int]struct {
			result1 *repositoryhost.URL
			result2 error
		})
	}
	fake.resourceURLReturnsOnCall[i] = struct {
		result1 *repositoryhost.URL
		result2 error
	}{result1, result2}
}

func (fake *FakeInterface) Tree(arg1 repositoryhost.URL) ([]string, error) {
	fake.treeMutex.Lock()
	ret, specificReturn := fake.treeReturnsOnCall[len(fake.treeArgsForCall)]
	fake.treeArgsForCall = append(fake.treeArgsForCall, struct {
		arg1 repositoryhost.URL
	}{arg1})
	stub := fake.TreeStub
	fakeReturns := fake.treeReturns
	fake.recordInvocation("Tree", []interface{}{arg1})
	fake.treeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInterface) TreeCallCount() int {
	fake.treeMutex.RLock()
	defer fake.treeMutex.RUnlock()
	return len(fake.treeArgsForCall)
}

func (fake *FakeInterface) TreeCalls(stub func(repositoryhost.URL) ([]string, error)) {
	fake.treeMutex.Lock()
	defer fake.treeMutex.Unlock()
	fake.TreeStub = stub
}

func (fake *FakeInterface) TreeArgsForCall(i int) repositoryhost.URL {
	fake.treeMutex.RLock()
	defer fake.treeMutex.RUnlock()
	argsForCall := fake.treeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeInterface) TreeReturns(result1 []string, result2 error) {
	fake.treeMutex.Lock()
	defer fake.treeMutex.Unlock()
	fake.TreeStub = nil
	fake.treeReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeInterface) TreeReturnsOnCall(i int, result1 []string, result2 error) {
	fake.treeMutex.Lock()
	defer fake.treeMutex.Unlock()
	fake.TreeStub = nil
	if fake.treeReturnsOnCall == nil {
		fake.treeReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.treeReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.acceptMutex.RLock()
	defer fake.acceptMutex.RUnlock()
	fake.getClientMutex.RLock()
	defer fake.getClientMutex.RUnlock()
	fake.getRateLimitMutex.RLock()
	defer fake.getRateLimitMutex.RUnlock()
	fake.loadRepositoryMutex.RLock()
	defer fake.loadRepositoryMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	fake.repositoriesMutex.RLock()
	defer fake.repositoriesMutex.RUnlock()
	fake.resolveRelativeLinkMutex.RLock()
	defer fake.resolveRelativeLinkMutex.RUnlock()
	fake.resourceURLMutex.RLock()
	defer fake.resourceURLMutex.RUnlock()
	fake.treeMutex.RLock()
	defer fake.treeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ repositoryhost.Interface = new(FakeInterface)
