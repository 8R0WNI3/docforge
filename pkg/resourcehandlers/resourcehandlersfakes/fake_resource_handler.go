// SPDX-FileCopyrightText: 2021 SAP SE or an SAP affiliate company and Gardener contributors
//
// SPDX-License-Identifier: Apache-2.0
// Code generated by counterfeiter. DO NOT EDIT.
package resourcehandlersfakes

import (
	"context"
	"sync"
	"time"

	"github.com/gardener/docforge/pkg/resourcehandlers"
	"github.com/gardener/docforge/pkg/util/httpclient"
)

type FakeResourceHandler struct {
	AcceptStub        func(string) bool
	acceptMutex       sync.RWMutex
	acceptArgsForCall []struct {
		arg1 string
	}
	acceptReturns struct {
		result1 bool
	}
	acceptReturnsOnCall map[int]struct {
		result1 bool
	}
	BuildAbsLinkStub        func(string, string) (string, error)
	buildAbsLinkMutex       sync.RWMutex
	buildAbsLinkArgsForCall []struct {
		arg1 string
		arg2 string
	}
	buildAbsLinkReturns struct {
		result1 string
		result2 error
	}
	buildAbsLinkReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	FileTreeFromUrlStub        func(string) ([]string, error)
	fileTreeFromUrlMutex       sync.RWMutex
	fileTreeFromUrlArgsForCall []struct {
		arg1 string
	}
	fileTreeFromUrlReturns struct {
		result1 []string
		result2 error
	}
	fileTreeFromUrlReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	GetClientStub        func() httpclient.Client
	getClientMutex       sync.RWMutex
	getClientArgsForCall []struct {
	}
	getClientReturns struct {
		result1 httpclient.Client
	}
	getClientReturnsOnCall map[int]struct {
		result1 httpclient.Client
	}
	GetRateLimitStub        func(context.Context) (int, int, time.Time, error)
	getRateLimitMutex       sync.RWMutex
	getRateLimitArgsForCall []struct {
		arg1 context.Context
	}
	getRateLimitReturns struct {
		result1 int
		result2 int
		result3 time.Time
		result4 error
	}
	getRateLimitReturnsOnCall map[int]struct {
		result1 int
		result2 int
		result3 time.Time
		result4 error
	}
	GetRawFormatLinkStub        func(string) (string, error)
	getRawFormatLinkMutex       sync.RWMutex
	getRawFormatLinkArgsForCall []struct {
		arg1 string
	}
	getRawFormatLinkReturns struct {
		result1 string
		result2 error
	}
	getRawFormatLinkReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ManifestFromUrlStub        func(string) (string, error)
	manifestFromUrlMutex       sync.RWMutex
	manifestFromUrlArgsForCall []struct {
		arg1 string
	}
	manifestFromUrlReturns struct {
		result1 string
		result2 error
	}
	manifestFromUrlReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ReadStub        func(context.Context, string) ([]byte, error)
	readMutex       sync.RWMutex
	readArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	readReturns struct {
		result1 []byte
		result2 error
	}
	readReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	ReadGitInfoStub        func(context.Context, string) ([]byte, error)
	readGitInfoMutex       sync.RWMutex
	readGitInfoArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	readGitInfoReturns struct {
		result1 []byte
		result2 error
	}
	readGitInfoReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeResourceHandler) Accept(arg1 string) bool {
	fake.acceptMutex.Lock()
	ret, specificReturn := fake.acceptReturnsOnCall[len(fake.acceptArgsForCall)]
	fake.acceptArgsForCall = append(fake.acceptArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.AcceptStub
	fakeReturns := fake.acceptReturns
	fake.recordInvocation("Accept", []interface{}{arg1})
	fake.acceptMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResourceHandler) AcceptCallCount() int {
	fake.acceptMutex.RLock()
	defer fake.acceptMutex.RUnlock()
	return len(fake.acceptArgsForCall)
}

func (fake *FakeResourceHandler) AcceptCalls(stub func(string) bool) {
	fake.acceptMutex.Lock()
	defer fake.acceptMutex.Unlock()
	fake.AcceptStub = stub
}

func (fake *FakeResourceHandler) AcceptArgsForCall(i int) string {
	fake.acceptMutex.RLock()
	defer fake.acceptMutex.RUnlock()
	argsForCall := fake.acceptArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResourceHandler) AcceptReturns(result1 bool) {
	fake.acceptMutex.Lock()
	defer fake.acceptMutex.Unlock()
	fake.AcceptStub = nil
	fake.acceptReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeResourceHandler) AcceptReturnsOnCall(i int, result1 bool) {
	fake.acceptMutex.Lock()
	defer fake.acceptMutex.Unlock()
	fake.AcceptStub = nil
	if fake.acceptReturnsOnCall == nil {
		fake.acceptReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.acceptReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeResourceHandler) BuildAbsLink(arg1 string, arg2 string) (string, error) {
	fake.buildAbsLinkMutex.Lock()
	ret, specificReturn := fake.buildAbsLinkReturnsOnCall[len(fake.buildAbsLinkArgsForCall)]
	fake.buildAbsLinkArgsForCall = append(fake.buildAbsLinkArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.BuildAbsLinkStub
	fakeReturns := fake.buildAbsLinkReturns
	fake.recordInvocation("BuildAbsLink", []interface{}{arg1, arg2})
	fake.buildAbsLinkMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceHandler) BuildAbsLinkCallCount() int {
	fake.buildAbsLinkMutex.RLock()
	defer fake.buildAbsLinkMutex.RUnlock()
	return len(fake.buildAbsLinkArgsForCall)
}

func (fake *FakeResourceHandler) BuildAbsLinkCalls(stub func(string, string) (string, error)) {
	fake.buildAbsLinkMutex.Lock()
	defer fake.buildAbsLinkMutex.Unlock()
	fake.BuildAbsLinkStub = stub
}

func (fake *FakeResourceHandler) BuildAbsLinkArgsForCall(i int) (string, string) {
	fake.buildAbsLinkMutex.RLock()
	defer fake.buildAbsLinkMutex.RUnlock()
	argsForCall := fake.buildAbsLinkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceHandler) BuildAbsLinkReturns(result1 string, result2 error) {
	fake.buildAbsLinkMutex.Lock()
	defer fake.buildAbsLinkMutex.Unlock()
	fake.BuildAbsLinkStub = nil
	fake.buildAbsLinkReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) BuildAbsLinkReturnsOnCall(i int, result1 string, result2 error) {
	fake.buildAbsLinkMutex.Lock()
	defer fake.buildAbsLinkMutex.Unlock()
	fake.BuildAbsLinkStub = nil
	if fake.buildAbsLinkReturnsOnCall == nil {
		fake.buildAbsLinkReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.buildAbsLinkReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) FileTreeFromUrl(arg1 string) ([]string, error) {
	fake.fileTreeFromUrlMutex.Lock()
	ret, specificReturn := fake.fileTreeFromUrlReturnsOnCall[len(fake.fileTreeFromUrlArgsForCall)]
	fake.fileTreeFromUrlArgsForCall = append(fake.fileTreeFromUrlArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FileTreeFromUrlStub
	fakeReturns := fake.fileTreeFromUrlReturns
	fake.recordInvocation("FileTreeFromUrl", []interface{}{arg1})
	fake.fileTreeFromUrlMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceHandler) FileTreeFromUrlCallCount() int {
	fake.fileTreeFromUrlMutex.RLock()
	defer fake.fileTreeFromUrlMutex.RUnlock()
	return len(fake.fileTreeFromUrlArgsForCall)
}

func (fake *FakeResourceHandler) FileTreeFromUrlCalls(stub func(string) ([]string, error)) {
	fake.fileTreeFromUrlMutex.Lock()
	defer fake.fileTreeFromUrlMutex.Unlock()
	fake.FileTreeFromUrlStub = stub
}

func (fake *FakeResourceHandler) FileTreeFromUrlArgsForCall(i int) string {
	fake.fileTreeFromUrlMutex.RLock()
	defer fake.fileTreeFromUrlMutex.RUnlock()
	argsForCall := fake.fileTreeFromUrlArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResourceHandler) FileTreeFromUrlReturns(result1 []string, result2 error) {
	fake.fileTreeFromUrlMutex.Lock()
	defer fake.fileTreeFromUrlMutex.Unlock()
	fake.FileTreeFromUrlStub = nil
	fake.fileTreeFromUrlReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) FileTreeFromUrlReturnsOnCall(i int, result1 []string, result2 error) {
	fake.fileTreeFromUrlMutex.Lock()
	defer fake.fileTreeFromUrlMutex.Unlock()
	fake.FileTreeFromUrlStub = nil
	if fake.fileTreeFromUrlReturnsOnCall == nil {
		fake.fileTreeFromUrlReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.fileTreeFromUrlReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) GetClient() httpclient.Client {
	fake.getClientMutex.Lock()
	ret, specificReturn := fake.getClientReturnsOnCall[len(fake.getClientArgsForCall)]
	fake.getClientArgsForCall = append(fake.getClientArgsForCall, struct {
	}{})
	stub := fake.GetClientStub
	fakeReturns := fake.getClientReturns
	fake.recordInvocation("GetClient", []interface{}{})
	fake.getClientMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResourceHandler) GetClientCallCount() int {
	fake.getClientMutex.RLock()
	defer fake.getClientMutex.RUnlock()
	return len(fake.getClientArgsForCall)
}

func (fake *FakeResourceHandler) GetClientCalls(stub func() httpclient.Client) {
	fake.getClientMutex.Lock()
	defer fake.getClientMutex.Unlock()
	fake.GetClientStub = stub
}

func (fake *FakeResourceHandler) GetClientReturns(result1 httpclient.Client) {
	fake.getClientMutex.Lock()
	defer fake.getClientMutex.Unlock()
	fake.GetClientStub = nil
	fake.getClientReturns = struct {
		result1 httpclient.Client
	}{result1}
}

func (fake *FakeResourceHandler) GetClientReturnsOnCall(i int, result1 httpclient.Client) {
	fake.getClientMutex.Lock()
	defer fake.getClientMutex.Unlock()
	fake.GetClientStub = nil
	if fake.getClientReturnsOnCall == nil {
		fake.getClientReturnsOnCall = make(map[int]struct {
			result1 httpclient.Client
		})
	}
	fake.getClientReturnsOnCall[i] = struct {
		result1 httpclient.Client
	}{result1}
}

func (fake *FakeResourceHandler) GetRateLimit(arg1 context.Context) (int, int, time.Time, error) {
	fake.getRateLimitMutex.Lock()
	ret, specificReturn := fake.getRateLimitReturnsOnCall[len(fake.getRateLimitArgsForCall)]
	fake.getRateLimitArgsForCall = append(fake.getRateLimitArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.GetRateLimitStub
	fakeReturns := fake.getRateLimitReturns
	fake.recordInvocation("GetRateLimit", []interface{}{arg1})
	fake.getRateLimitMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *FakeResourceHandler) GetRateLimitCallCount() int {
	fake.getRateLimitMutex.RLock()
	defer fake.getRateLimitMutex.RUnlock()
	return len(fake.getRateLimitArgsForCall)
}

func (fake *FakeResourceHandler) GetRateLimitCalls(stub func(context.Context) (int, int, time.Time, error)) {
	fake.getRateLimitMutex.Lock()
	defer fake.getRateLimitMutex.Unlock()
	fake.GetRateLimitStub = stub
}

func (fake *FakeResourceHandler) GetRateLimitArgsForCall(i int) context.Context {
	fake.getRateLimitMutex.RLock()
	defer fake.getRateLimitMutex.RUnlock()
	argsForCall := fake.getRateLimitArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResourceHandler) GetRateLimitReturns(result1 int, result2 int, result3 time.Time, result4 error) {
	fake.getRateLimitMutex.Lock()
	defer fake.getRateLimitMutex.Unlock()
	fake.GetRateLimitStub = nil
	fake.getRateLimitReturns = struct {
		result1 int
		result2 int
		result3 time.Time
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeResourceHandler) GetRateLimitReturnsOnCall(i int, result1 int, result2 int, result3 time.Time, result4 error) {
	fake.getRateLimitMutex.Lock()
	defer fake.getRateLimitMutex.Unlock()
	fake.GetRateLimitStub = nil
	if fake.getRateLimitReturnsOnCall == nil {
		fake.getRateLimitReturnsOnCall = make(map[int]struct {
			result1 int
			result2 int
			result3 time.Time
			result4 error
		})
	}
	fake.getRateLimitReturnsOnCall[i] = struct {
		result1 int
		result2 int
		result3 time.Time
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeResourceHandler) GetRawFormatLink(arg1 string) (string, error) {
	fake.getRawFormatLinkMutex.Lock()
	ret, specificReturn := fake.getRawFormatLinkReturnsOnCall[len(fake.getRawFormatLinkArgsForCall)]
	fake.getRawFormatLinkArgsForCall = append(fake.getRawFormatLinkArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetRawFormatLinkStub
	fakeReturns := fake.getRawFormatLinkReturns
	fake.recordInvocation("GetRawFormatLink", []interface{}{arg1})
	fake.getRawFormatLinkMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceHandler) GetRawFormatLinkCallCount() int {
	fake.getRawFormatLinkMutex.RLock()
	defer fake.getRawFormatLinkMutex.RUnlock()
	return len(fake.getRawFormatLinkArgsForCall)
}

func (fake *FakeResourceHandler) GetRawFormatLinkCalls(stub func(string) (string, error)) {
	fake.getRawFormatLinkMutex.Lock()
	defer fake.getRawFormatLinkMutex.Unlock()
	fake.GetRawFormatLinkStub = stub
}

func (fake *FakeResourceHandler) GetRawFormatLinkArgsForCall(i int) string {
	fake.getRawFormatLinkMutex.RLock()
	defer fake.getRawFormatLinkMutex.RUnlock()
	argsForCall := fake.getRawFormatLinkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResourceHandler) GetRawFormatLinkReturns(result1 string, result2 error) {
	fake.getRawFormatLinkMutex.Lock()
	defer fake.getRawFormatLinkMutex.Unlock()
	fake.GetRawFormatLinkStub = nil
	fake.getRawFormatLinkReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) GetRawFormatLinkReturnsOnCall(i int, result1 string, result2 error) {
	fake.getRawFormatLinkMutex.Lock()
	defer fake.getRawFormatLinkMutex.Unlock()
	fake.GetRawFormatLinkStub = nil
	if fake.getRawFormatLinkReturnsOnCall == nil {
		fake.getRawFormatLinkReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getRawFormatLinkReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) ManifestFromUrl(arg1 string) (string, error) {
	fake.manifestFromUrlMutex.Lock()
	ret, specificReturn := fake.manifestFromUrlReturnsOnCall[len(fake.manifestFromUrlArgsForCall)]
	fake.manifestFromUrlArgsForCall = append(fake.manifestFromUrlArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ManifestFromUrlStub
	fakeReturns := fake.manifestFromUrlReturns
	fake.recordInvocation("ManifestFromUrl", []interface{}{arg1})
	fake.manifestFromUrlMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceHandler) ManifestFromUrlCallCount() int {
	fake.manifestFromUrlMutex.RLock()
	defer fake.manifestFromUrlMutex.RUnlock()
	return len(fake.manifestFromUrlArgsForCall)
}

func (fake *FakeResourceHandler) ManifestFromUrlCalls(stub func(string) (string, error)) {
	fake.manifestFromUrlMutex.Lock()
	defer fake.manifestFromUrlMutex.Unlock()
	fake.ManifestFromUrlStub = stub
}

func (fake *FakeResourceHandler) ManifestFromUrlArgsForCall(i int) string {
	fake.manifestFromUrlMutex.RLock()
	defer fake.manifestFromUrlMutex.RUnlock()
	argsForCall := fake.manifestFromUrlArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResourceHandler) ManifestFromUrlReturns(result1 string, result2 error) {
	fake.manifestFromUrlMutex.Lock()
	defer fake.manifestFromUrlMutex.Unlock()
	fake.ManifestFromUrlStub = nil
	fake.manifestFromUrlReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) ManifestFromUrlReturnsOnCall(i int, result1 string, result2 error) {
	fake.manifestFromUrlMutex.Lock()
	defer fake.manifestFromUrlMutex.Unlock()
	fake.ManifestFromUrlStub = nil
	if fake.manifestFromUrlReturnsOnCall == nil {
		fake.manifestFromUrlReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.manifestFromUrlReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) Read(arg1 context.Context, arg2 string) ([]byte, error) {
	fake.readMutex.Lock()
	ret, specificReturn := fake.readReturnsOnCall[len(fake.readArgsForCall)]
	fake.readArgsForCall = append(fake.readArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ReadStub
	fakeReturns := fake.readReturns
	fake.recordInvocation("Read", []interface{}{arg1, arg2})
	fake.readMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceHandler) ReadCallCount() int {
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	return len(fake.readArgsForCall)
}

func (fake *FakeResourceHandler) ReadCalls(stub func(context.Context, string) ([]byte, error)) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = stub
}

func (fake *FakeResourceHandler) ReadArgsForCall(i int) (context.Context, string) {
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	argsForCall := fake.readArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceHandler) ReadReturns(result1 []byte, result2 error) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = nil
	fake.readReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) ReadReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = nil
	if fake.readReturnsOnCall == nil {
		fake.readReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.readReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) ReadGitInfo(arg1 context.Context, arg2 string) ([]byte, error) {
	fake.readGitInfoMutex.Lock()
	ret, specificReturn := fake.readGitInfoReturnsOnCall[len(fake.readGitInfoArgsForCall)]
	fake.readGitInfoArgsForCall = append(fake.readGitInfoArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ReadGitInfoStub
	fakeReturns := fake.readGitInfoReturns
	fake.recordInvocation("ReadGitInfo", []interface{}{arg1, arg2})
	fake.readGitInfoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceHandler) ReadGitInfoCallCount() int {
	fake.readGitInfoMutex.RLock()
	defer fake.readGitInfoMutex.RUnlock()
	return len(fake.readGitInfoArgsForCall)
}

func (fake *FakeResourceHandler) ReadGitInfoCalls(stub func(context.Context, string) ([]byte, error)) {
	fake.readGitInfoMutex.Lock()
	defer fake.readGitInfoMutex.Unlock()
	fake.ReadGitInfoStub = stub
}

func (fake *FakeResourceHandler) ReadGitInfoArgsForCall(i int) (context.Context, string) {
	fake.readGitInfoMutex.RLock()
	defer fake.readGitInfoMutex.RUnlock()
	argsForCall := fake.readGitInfoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceHandler) ReadGitInfoReturns(result1 []byte, result2 error) {
	fake.readGitInfoMutex.Lock()
	defer fake.readGitInfoMutex.Unlock()
	fake.ReadGitInfoStub = nil
	fake.readGitInfoReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) ReadGitInfoReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.readGitInfoMutex.Lock()
	defer fake.readGitInfoMutex.Unlock()
	fake.ReadGitInfoStub = nil
	if fake.readGitInfoReturnsOnCall == nil {
		fake.readGitInfoReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.readGitInfoReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.acceptMutex.RLock()
	defer fake.acceptMutex.RUnlock()
	fake.buildAbsLinkMutex.RLock()
	defer fake.buildAbsLinkMutex.RUnlock()
	fake.fileTreeFromUrlMutex.RLock()
	defer fake.fileTreeFromUrlMutex.RUnlock()
	fake.getClientMutex.RLock()
	defer fake.getClientMutex.RUnlock()
	fake.getRateLimitMutex.RLock()
	defer fake.getRateLimitMutex.RUnlock()
	fake.getRawFormatLinkMutex.RLock()
	defer fake.getRawFormatLinkMutex.RUnlock()
	fake.manifestFromUrlMutex.RLock()
	defer fake.manifestFromUrlMutex.RUnlock()
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	fake.readGitInfoMutex.RLock()
	defer fake.readGitInfoMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeResourceHandler) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ resourcehandlers.ResourceHandler = new(FakeResourceHandler)
